---
title: "Giotto_Seurat_interoperability"
author: "Iqra Amin"
date: "2024-03-06"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Interoperability: Seurat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

Giotto facilitates seamless interoperability with various tools, including Seurat. The conversion between Giotto and Seurat relies on four primary functions. 'giottoToSeurat_v4' and 'SeuratToGiotto_v4' cater to Seurat version 4 , while 'giottoToSeurat_v5' and 'SeuratToGiotto_v5' are specifically for Seurat version 5. These functions play a vital role in ensuring effortless data transitions between Giotto and Seurat across different versions, ensuring compatibility and ease of use.

## Conversion of Seurat V5 to Giotto

In this section, we outline the steps to convert a Seurat V5 object to Giotto, offering a seamless transition between these two.

### Load required Libraries 

To start, we load the required libraries.

```{r message=FALSE, warning=FALSE}
library(data.table)
library(Giotto)
library(GiottoData)
library(Seurat)
library(SeuratData)
```

### Load Seurat object

We begin by loading a sample Seurat object named "stxBrain" with the type specified as "anterior1".

```{r message=FALSE, warning=FALSE}
brain <- LoadData("stxBrain", type = "anterior1")
```

### Convert Seurat object to Giotto

To convert Seurat object to Giotto object, we use the function seuratToGiottoV5().

```{r message=FALSE, warning=FALSE}
brainG <- seuratToGiottoV5(sobject = brain, spatial_assay = "Spatial")
```

### Print Giotto object

```{r message=FALSE, warning=FALSE}
brainG
```

### Downstream Analysis using Giotto Object

The downstream analysis of the giotto object being created by seurat object is given below.

#### High Efficiency Data Processing

```{r processgiotto, message=FALSE, warning=FALSE}
brainG <- processGiotto(
    brainG,
    filter_params = list(expression_threshold = 1,
                         feat_det_in_min_cells = 100,
                         min_det_feats_per_cell = 10),
    norm_params = list(norm_methods = 'standard',
                       scale_feats = TRUE,
                       scalefactor = 6000),
    stat_params = list(expression_values = 'normalized'),
    adjust_params = list(expression_values = c('normalized'),
                         covariate_columns = 'nr_feats')
)
```

#### Dimension Reduction and PCA

First, we find HVF (highly varialble features) using the loess regression prediction model.

```{r giotto-hvf, message=FALSE}
brainG <- calculateHVF(gobject = brainG, method = 'cov_loess')
```

then use HVF to compute the reduced dimensions using PCA.

```{r giotto-pca, message=FALSE}
## Select genes highly variable genes that fit specified statistics
# These are both found within feature metadata
feature_metadata = getFeatureMetadata(brainG)[]
featgenes = feature_metadata[hvf == 'yes' & perc_cells > 4 & mean_expr_det > 0.5]$feat_ID

## run PCA on expression values (default)
brainG <- Giotto::runPCA(gobject = brainG, feats_to_use = featgenes, scale_unit = F, center = F)
```

Here, we'll proceed with running UMAP based on PCA dimension reduction and visualize the pre-clustering UMAP.

```{r giotto-umap, message=FALSE, warning=FALSE}
brainG <- Giotto::runUMAP(brainG, dimensions_to_use = 1:15)
graph1 <- Giotto::plotUMAP(gobject = brainG)

```

#### Clustering

Before proceeding with clustering cells based on their expression profiles, ensure that the Giotto Object has undergone PCA dimension reduction and includes either t-SNE or UMAP dimension reduction, as well as a defined neighbor network.

To initialize the clustering process, create a shared nearest neighbor network (sNN) with a specified number of nearest neighbors ('k'):

```{r giotto-nn}
brainG <- createNearestNetwork(gobject = brainG, type = "sNN", dimensions_to_use = 1:15, k = 15)
```

In Giotto, various clustering algorithms are available, such as k-means, Leiden, or Louvain. These algorithms automatically store cluster information within cell metadata, typically following default naming conventions. However, you can easily customize the cluster name by specifying the 'name' argument.

```{r giotto-kmeans}
## k-means clustering
brainG <- doKmeans(gobject = brainG, dim_reduction_to_use = 'pca')

#Plot UMAP post-clustering to visualize kmeans
graph2 <- Giotto::plotUMAP(
    gobject = brainG,
    cell_color = 'kmeans',
    show_NN_network = T,
    point_size = 2.5
)
```

#### Spatial co-expression

Using the spatial network previously established, we can employ the binSpect method to identify spatially variable genes.

```{r giotto-binspect, message=FALSE}
brainG <- Giotto::createSpatialDelaunayNetwork(gobject = brainG)
showGiottoSpatNetworks(brainG)

ranktest = binSpect(
    brainG, bin_method = 'rank',
    calc_hub = T, hub_min_int = 5,
    spatial_network_name = 'Delaunay_network'
)
```

Here, we'll narrow down our analysis by selecting the top 300 spatial genes identified through binSpect. Additionally, we'll illustrate how to identify the genes that exhibit the highest spatial correlation.

```{r spatial-cor-genes}
# 3.1 cluster the top 500 spatial genes into 20 clusters
ext_spatial_genes = ranktest[1:300,]$feats

# here we use existing detectSpatialCorGenes function to calculate pairwise distances between genes (but set network_smoothing=0 to use default clustering)
spat_cor_netw_DT = detectSpatialCorFeats(
    brainG,
    method = 'network',
    spatial_network_name = 'Delaunay_network',
    subset_feats = ext_spatial_genes
)
# 3.2 identify most similar spatially correlated genes for one gene
top10_genes = showSpatialCorFeats(spat_cor_netw_DT, feats = 'Dsp', show_top_feats = 10)
```

Employing the pheatmap function, we can visualize spatial co-expression modules and iteratively adjust the number of clusters (k) for optimal representation.

```{r coexpression-modules}
# 3.3 identify potenial spatial co-expression
spat_cor_netw_DT = clusterSpatialCorFeats(spat_cor_netw_DT, name = 'spat_netw_clus', k = 7)

# visualize clusters
graph3 <- heatmSpatialCorFeats(
    brainG,
    spatCorObject = spat_cor_netw_DT,
    use_clus_name = 'spat_netw_clus',
    heatmap_legend_param = list(title = NULL),
    save_param = list(base_height = 6, base_width = 8, units = 'cm'), 
    show_plot =  TRUE,
    return_plot = FALSE,
    save_plot = TRUE
)
```

We'll proceed by isolating genes from individual co-expression modules and then consolidate them into meta-genes through aggregation.

```{r balanced-spat-coexpression-feats, message=FALSE, include=FALSE}
# 3.4 create metagenes / co-expression modules
cluster_genes = getBalancedSpatCoexpressionFeats(spat_cor_netw_DT, maximum = 30)
```

```{r create-meta-feats, fig.width=10, fig.height=8}
brainG = createMetafeats(brainG, feat_clusters = cluster_genes, name = 'cluster_metagene')                     
    
    
graph4 <- spatCellPlot(
    brainG,
    spat_enr_names = 'cluster_metagene',
    cell_annotation_values = as.character(c(1:7)),
    point_size = 1, cow_n_col = 3, gradient_style = 'sequential'
)   
```


## Conversion of Giotto to Seurat V5

With Seurat's recent upgrade to version 5, ensuring compatibility is essential. The 'giottoToSeuratV5()' function simplifies the process by seamlessly converting Giotto objects to the latest Seurat object.

### Reverting GiottoObj to Seurat

In this step, we revert the Giotto object, previously converted from Seurat, back to its original Seurat format:

```{r echo=TRUE, message=FALSE, warning=FALSE}
brain2 <- giottoToSeuratV5(brainG)
```

### Print Seurat Object

```{r}
brain2
```

### Downstream Analysis of Giotto to Seurat V5:

Following the conversion of Giotto to Seurat V5, downstream analysis can be conducted as outlined below:

#### Load libraries

Load Required Libraries

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(Seurat)
library(SeuratData)
library(ggplot2)
library(patchwork)
library(dplyr)
```

#### Visualization of Cell Counts Distribution
 
Visualize the distribution of cell counts using violin plots and spatial feature plots:

```{r}
plot1 <- VlnPlot(brain2, features = "nCount_rna", pt.size = 0.1) + NoLegend()

plot2 <- SpatialFeaturePlot(brain2, features = "nCount_rna") + theme(legend.position = "right")
wrap_plots(plot1, plot2)

```

####  Data Transformation

To enhance the analysis, we apply SCTransform to perform data transformation on the RNA assay:

```{r, warning=FALSE}
brain2 <- SCTransform(brain2, assay = "rna", verbose = FALSE)
```

#### Dimensionality Reduction and Clustering

Following data transformation, we proceed with dimensionality reduction and clustering. This involves conducting PCA, identifying neighbors, performing clustering, and running UMAP for dimensionality reduction:

```{r message=FALSE, warning=FALSE}
brain2 <- RunPCA(brain2, assay = "SCT", verbose = FALSE)
brain2 <- FindNeighbors(brain2, reduction = "pca", dims = 1:30)
brain2 <- FindClusters(brain2, verbose = FALSE)
brain2 <- RunUMAP(brain2, reduction = "pca", dims = 1:30)
```

#### Visualization of Clusters on UMAP

To visualize clusters on UMAP, we generate dimensional plots with cluster labels for better interpretation:

```{r message=FALSE, warning=FALSE}
p1 <- DimPlot(brain2, reduction = "umap", label = TRUE)
p2 <- SpatialDimPlot(brain2, label = TRUE, label.size = 3)
p1 + p2
```

Additionally, we can highlight specific cell populations within the spatial dimensional plot:

```{r message=FALSE, warning=FALSE}
SpatialDimPlot(brain2, cells.highlight = CellsByIdentities(object = brain2, idents = c(2, 1, 4, 3,
    5, 8)), facet.highlight = TRUE, ncol = 3)
```

#### Identification of Spatially Variable Features

To identify spatially variable features between clusters, the FindMarkers function is employed. Subsequently, we visualize the top spatially variable features using SpatialFeaturePlot:

```{r message=FALSE, warning=FALSE}
de_markers <- FindMarkers(brain2, ident.1 = 5, ident.2 = 6)
SpatialFeaturePlot(object = brain2, features = rownames(de_markers)[1:3], alpha = c(0.1, 1), ncol = 3)
```

we identify spatially variable features within the spatial data. This is achieved through the `FindSpatiallyVariableFeatures` function, which calculates spatial statistics to determine the variability of features across spatial locations. In the following code chunk, we focus on the top 1000 variable features selected from the SCT assay using the Moransi selection method.

```{r message=FALSE, warning=FALSE}
brain2 <- FindSpatiallyVariableFeatures(brain2, assay = "SCT", features = VariableFeatures(brain2)[1:1000],
    selection.method = "moransi")
```
#### Subset out anatomical regions

This section focuses on subsetting anatomical regions from the dataset and visualizing them using spatial dimensional plots.

```{r message=FALSE, warning=FALSE}
cortex <- subset(brain2, idents = c(1, 2, 3, 4, 6, 7))
cortex <- subset(cortex, anterior1_imagerow > 400 | anterior1_imagecol < 150, invert = TRUE)
cortex <- subset(cortex, anterior1_imagerow > 275 & anterior1_imagecol > 370, invert = TRUE)
cortex <- subset(cortex, anterior1_imagerow > 250 & anterior1_imagecol > 440, invert = TRUE)
p1 <- SpatialDimPlot(cortex, crop = TRUE, label = TRUE)
p2 <- SpatialDimPlot(cortex, crop = FALSE, label = TRUE, pt.size.factor = 1, label.size = 3)
p1 + p2
```

#### Working with multiple slices in Seurat

To incorporate data from multiple slices in our analysis, we first load and transform the posterior slice:

```{r message=FALSE, warning=FALSE}
brainP <- LoadData("stxBrain", type = "posterior1")
brainP <- SCTransform(brainP, assay = "Spatial", verbose = FALSE)
```

Next, we merge the datasets obtained from the anterior and posterior slices:

```{r message=FALSE, warning=FALSE}

brain.merge <- merge(brain2, brainP)
```

We set the default assay to "SCT" and combine variable features from both datasets:

```{r message=FALSE, warning=FALSE}
DefaultAssay(brain.merge) <- "SCT"
VariableFeatures(brain.merge) <- c(VariableFeatures(brain), VariableFeatures(brain2))
brain.merge <- RunPCA(brain.merge, verbose = FALSE)
brain.merge <- FindNeighbors(brain.merge, dims = 1:30)
brain.merge <- FindClusters(brain.merge, verbose = FALSE)
brain.merge <- RunUMAP(brain.merge, dims = 1:30)
```

After performing PCA, identifying neighbors, clustering, and running UMAP, we visualize the results:

```{r message=FALSE, warning=FALSE}
DimPlot(brain.merge, reduction = "umap", group.by = c("ident", "orig.ident"))
```

```{r message=FALSE, warning=FALSE}
SpatialDimPlot(brain.merge)
```

```{r message=FALSE, warning=FALSE}
SpatialFeaturePlot(brain.merge, features = c("Hpca", "Plp1"))
```

```{r}
sessionInfo()
```

